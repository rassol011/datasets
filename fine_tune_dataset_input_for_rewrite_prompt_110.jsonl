{"id": "0001", "prompt": "Act as an assistant and explain step by step how to reverse a singly linked list in Python.", "response": "Use three pointers (prev, curr, next). Iterate through the list, redirect curr.next to prev, then advance all pointers until curr is None; prev becomes the new head.", "metadata": {"task_category": "explanation", "domain": "software", "difficulty": "easy"}}
{"id": "0002", "prompt": "Explain how to reverse a singly linked list step by step in Python.", "response": "Iterate through nodes while keeping track of the previous node. Repoint each node’s next reference to the previous node, then return the last processed node as the new head.", "metadata": {"task_category": "explanation", "domain": "software", "difficulty": "easy"}}
{"id": "0003", "prompt": "Help me understand, step by step, the difference between REST and GraphQL for an internal API.", "response": "REST typically exposes multiple resource endpoints and uses HTTP semantics; GraphQL exposes a single endpoint where clients specify required fields, reducing over/under-fetching while adding schema and query complexity.", "metadata": {"task_category": "comparison", "domain": "software", "difficulty": "medium"}}
{"id": "0004", "prompt": "Compare REST and GraphQL step by step for an internal API use case.", "response": "REST structures operations around resources and verbs; GraphQL structures around a typed schema and client-defined queries. Trade-offs are caching and simplicity (REST) versus flexibility and field-level selection (GraphQL).", "metadata": {"task_category": "comparison", "domain": "software", "difficulty": "medium"}}
{"id": "0005", "prompt": "Act as an AI and provide step by step reasoning for why idempotency matters in payment processing.", "response": "Idempotency prevents duplicate side effects when requests retry due to timeouts or network errors. In payments, it reduces double-charging risk by ensuring repeated identical requests produce the same outcome.", "metadata": {"task_category": "explanation", "domain": "fintech", "difficulty": "medium"}}
{"id": "0006", "prompt": "Provide step by step reasoning for why idempotency matters in payment processing.", "response": "Retries happen; without idempotency, the same request can create multiple charges. With an idempotency key, the processor returns the original result and avoids repeated side effects.", "metadata": {"task_category": "explanation", "domain": "fintech", "difficulty": "medium"}}
{"id": "0007", "prompt": "Act as an assistant: help me understand step by step how to normalize a relational database table to 3NF.", "response": "Move repeating groups into separate tables (1NF), remove partial dependencies on composite keys (2NF), then remove transitive dependencies so non-key attributes depend only on the key (3NF).", "metadata": {"task_category": "explanation", "domain": "data", "difficulty": "hard"}}
{"id": "0008", "prompt": "Explain step by step how to normalize a relational database table to 3NF.", "response": "Ensure atomic columns (1NF), eliminate partial key dependencies (2NF), and eliminate transitive dependencies among non-key attributes (3NF).", "metadata": {"task_category": "explanation", "domain": "data", "difficulty": "hard"}}
{"id": "0009", "prompt": "I’m onboarding new developers—act as an assistant and draft a concise “how we review PRs” checklist step by step.", "response": "Checklist: clear description; small scope; tests added/updated; security and privacy considerations; performance impact; docs updated; reviewer notes on design trade-offs; merge criteria and rollback plan.", "metadata": {"task_category": "writing", "domain": "software", "difficulty": "easy"}}
{"id": "0010", "prompt": "Draft a concise “how we review PRs” checklist step by step for onboarding new developers.", "response": "Include: purpose, scope, tests, lint/format, security, performance, documentation, reviewer feedback expectations, and merge/rollback criteria.", "metadata": {"task_category": "writing", "domain": "software", "difficulty": "easy"}}
{"id": "0011", "prompt": "Act as an assistant and debug this error step by step: 'TypeError: cannot unpack non-iterable NoneType object' in Python.", "response": "This usually occurs when you expect a function to return a tuple but it returns None. Check the called function’s return paths and ensure all branches return a tuple of the expected arity.", "metadata": {"task_category": "debugging", "domain": "software", "difficulty": "medium"}}
{"id": "0012", "prompt": "Debug this Python error step by step: 'TypeError: cannot unpack non-iterable NoneType object'.", "response": "Identify where unpacking occurs (e.g., a,b = f()). Ensure f() returns an iterable in all cases; add explicit returns, or handle None with a guard clause.", "metadata": {"task_category": "debugging", "domain": "software", "difficulty": "medium"}}
{"id": "0013", "prompt": "Act as an AI and write step by step instructions for rotating AWS access keys safely.", "response": "Create new keys for the IAM user, update secrets in your secret manager, deploy and verify, then deactivate and delete old keys. Prefer roles/STS to long-lived keys when possible.", "metadata": {"task_category": "procedural", "domain": "cloud", "difficulty": "medium"}}
{"id": "0014", "prompt": "Write step by step instructions for rotating AWS access keys safely.", "response": "Generate replacement keys, update applications via secret distribution, validate in production, then revoke old keys. Record the change and audit access logs.", "metadata": {"task_category": "procedural", "domain": "cloud", "difficulty": "medium"}}
{"id": "0015", "prompt": "Help me understand step by step what a circuit breaker pattern is and when to use it.", "response": "A circuit breaker prevents cascading failures by stopping calls to an unhealthy dependency after a threshold of errors. Use it when downstream services can fail or time out and you need fast failure plus recovery probing.", "metadata": {"task_category": "explanation", "domain": "software", "difficulty": "medium"}}
{"id": "0016", "prompt": "Explain step by step what the circuit breaker pattern is and when to use it.", "response": "Track errors/timeouts; open the circuit when failures exceed a threshold; fail fast while open; periodically allow test requests to close the circuit upon recovery.", "metadata": {"task_category": "explanation", "domain": "software", "difficulty": "medium"}}
{"id": "0017", "prompt": "Act as an assistant and help me understand step by step how to write a SQL query to find duplicate emails in a users table.", "response": "Group by email, count rows, and filter counts greater than 1. Optionally include MIN(id) to pick a canonical record and join back to fetch full rows.", "metadata": {"task_category": "sql", "domain": "data", "difficulty": "easy"}}
{"id": "0018", "prompt": "Write a SQL query step by step to find duplicate emails in a users table.", "response": "Use: SELECT email, COUNT(*) FROM users GROUP BY email HAVING COUNT(*)>1; then join to retrieve affected user rows if needed.", "metadata": {"task_category": "sql", "domain": "data", "difficulty": "easy"}}
{"id": "0019", "prompt": "Act as an assistant and create a step by step migration plan from a monolith to microservices for a small team.", "response": "Start with domain decomposition, then extract a single low-risk bounded context behind an API, add observability, introduce a strangler pattern, and iterate service-by-service with clear ownership and SLOs.", "metadata": {"task_category": "planning", "domain": "software", "difficulty": "hard"}}
{"id": "0020", "prompt": "Create a step by step migration plan from a monolith to microservices for a small team.", "response": "Identify domains, pick one thin vertical slice to extract, set up CI/CD and monitoring, route traffic gradually, and repeat while controlling operational overhead.", "metadata": {"task_category": "planning", "domain": "software", "difficulty": "hard"}}
{"id": "0021", "prompt": "Explain, step by step, how to calculate the standard deviation of a dataset.", "response": "Compute the mean, subtract it from each value, square differences, average them (variance; sample uses n-1), then take the square root to get standard deviation.", "metadata": {"task_category": "math", "domain": "data", "difficulty": "easy"}}
{"id": "0022", "prompt": "Help me understand step by step how to calculate the standard deviation of a dataset.", "response": "Mean → deviations → squared deviations → variance → square root. Choose population (n) or sample (n-1) depending on inference goal.", "metadata": {"task_category": "math", "domain": "data", "difficulty": "easy"}}
{"id": "0023", "prompt": "Act as an assistant and help me understand step by step how OAuth 2.0 authorization code flow works.", "response": "Client redirects user to authorization server, user authenticates/consents, server returns an authorization code to redirect URI, client exchanges code for tokens at the token endpoint, then calls APIs with the access token.", "metadata": {"task_category": "security_explanation", "domain": "security", "difficulty": "hard"}}
{"id": "0024", "prompt": "Explain step by step how OAuth 2.0 authorization code flow works.", "response": "Redirect → consent → code → token exchange → API call. Use PKCE for public clients to mitigate code interception.", "metadata": {"task_category": "security_explanation", "domain": "security", "difficulty": "hard"}}
{"id": "0025", "prompt": "Act as an AI and help me understand step by step how to do basic threat modeling for a new feature.", "response": "Define scope and assets, identify trust boundaries and entry points, enumerate threats (e.g., STRIDE), prioritize by likelihood/impact, then specify mitigations and test/monitor controls.", "metadata": {"task_category": "security_planning", "domain": "security", "difficulty": "hard"}}
{"id": "0026", "prompt": "Describe step by step how to do basic threat modeling for a new feature.", "response": "Scope assets and data flows, identify threats per component, rank risks, assign mitigations and owners, and validate through testing and logging.", "metadata": {"task_category": "security_planning", "domain": "security", "difficulty": "hard"}}
{"id": "0027", "prompt": "Act as an assistant and explain step by step how to interpret a p-value correctly.", "response": "A p-value is the probability of observing data at least as extreme as yours assuming the null hypothesis is true. It does not measure effect size or the probability the null is true.", "metadata": {"task_category": "statistics", "domain": "science", "difficulty": "medium"}}
{"id": "0028", "prompt": "Explain step by step how to interpret a p-value correctly.", "response": "It quantifies evidence against the null under the null model. Combine with effect sizes, confidence intervals, and study design to assess practical significance.", "metadata": {"task_category": "statistics", "domain": "science", "difficulty": "medium"}}
{"id": "0029", "prompt": "Act as an assistant and write step by step instructions for setting up a Python virtual environment on macOS.", "response": "Install Python, create venv (python -m venv .venv), activate it (source .venv/bin/activate), upgrade pip, then install dependencies from requirements.txt.", "metadata": {"task_category": "howto", "domain": "software", "difficulty": "easy"}}
{"id": "0030", "prompt": "Write step by step instructions for setting up a Python virtual environment on macOS.", "response": "Create and activate a venv, then pin and install dependencies. Use a .python-version tool like pyenv if you need consistent interpreter versions.", "metadata": {"task_category": "howto", "domain": "software", "difficulty": "easy"}}
{"id": "0031", "prompt": "Help me understand step by step why time zones cause bugs in scheduling systems.", "response": "Ambiguity during DST transitions, differing local rules, and naive datetime storage lead to misinterpretation. Use UTC storage with explicit time zone identifiers and convert at boundaries.", "metadata": {"task_category": "explanation", "domain": "software", "difficulty": "medium"}}
{"id": "0032", "prompt": "Explain step by step why time zones cause bugs in scheduling systems.", "response": "DST gaps/overlaps and regional rule changes break naive assumptions. Persist timestamps in UTC plus the user’s IANA zone and handle conversions explicitly.", "metadata": {"task_category": "explanation", "domain": "software", "difficulty": "medium"}}
{"id": "0033", "prompt": "Act as an assistant and produce step by step guidance for writing a clear incident postmortem.", "response": "State impact and timeline, identify root causes and contributing factors, list corrective actions with owners/dates, document detection and response gaps, and capture follow-ups to prevent recurrence.", "metadata": {"task_category": "writing", "domain": "operations", "difficulty": "medium"}}
{"id": "0034", "prompt": "Produce step by step guidance for writing a clear incident postmortem.", "response": "Include: summary, customer impact, timeline, contributing factors, root cause, what worked, what didn’t, and action items with measurable outcomes.", "metadata": {"task_category": "writing", "domain": "operations", "difficulty": "medium"}}
{"id": "0035", "prompt": "Act as an AI and help me understand step by step how a Bloom filter works.", "response": "A Bloom filter is a probabilistic set membership structure using multiple hash functions to set bits in a bit array. Queries check all corresponding bits; false positives are possible, false negatives are not (unless deletions are misused).", "metadata": {"task_category": "explanation", "domain": "computer_science", "difficulty": "hard"}}
{"id": "0036", "prompt": "Explain step by step how a Bloom filter works.", "response": "Insert: hash item k times and set bits. Query: hash item and confirm all bits are set. Tune bit-array size and k to control false positive rate.", "metadata": {"task_category": "explanation", "domain": "computer_science", "difficulty": "hard"}}
{"id": "0037", "prompt": "Act as an assistant and explain step by step how to write unit tests for a pure function.", "response": "Choose representative inputs, assert deterministic outputs, cover edge cases and invalid inputs, and keep tests independent and fast. Use parametrization to reduce duplication.", "metadata": {"task_category": "testing", "domain": "software", "difficulty": "easy"}}
{"id": "0038", "prompt": "Explain step by step how to write unit tests for a pure function.", "response": "Test normal cases, boundaries, and error handling; assert outputs only; avoid shared mutable state; aim for readable naming and minimal setup.", "metadata": {"task_category": "testing", "domain": "software", "difficulty": "easy"}}
{"id": "0039", "prompt": "Help me understand step by step how to design a rate limiter for an API gateway.", "response": "Select an algorithm (token bucket/leaky bucket/fixed or sliding window), define keys (user/IP/token), set limits and burst policy, store counters in a low-latency system, and ensure consistency across instances.", "metadata": {"task_category": "design", "domain": "software", "difficulty": "hard"}}
{"id": "0040", "prompt": "Design a rate limiter step by step for an API gateway.", "response": "Pick algorithm, define scope keys, decide storage and consistency model, implement enforcement and headers, and add monitoring plus override controls for incidents.", "metadata": {"task_category": "design", "domain": "software", "difficulty": "hard"}}
{"id": "0041", "prompt": "Act as an assistant and write step by step instructions for converting a CSV to JSON using Python.", "response": "Read CSV with csv.DictReader, accumulate rows, then dump with json.dump. Consider streaming for large files and enforce proper encoding.", "metadata": {"task_category": "code", "domain": "software", "difficulty": "easy"}}
{"id": "0042", "prompt": "Write step by step instructions for converting a CSV to JSON using Python.", "response": "Parse headers into dict keys, serialize rows to a list or stream JSON objects, and validate output schema (types, required fields).", "metadata": {"task_category": "code", "domain": "software", "difficulty": "easy"}}
{"id": "0043", "prompt": "Act as an AI and explain step by step how to estimate API capacity from QPS and latency targets.", "response": "Use Little’s Law (L=λW) to estimate concurrent in-flight requests given throughput and average latency, add headroom for p95/p99, and account for downstream dependencies and queueing under load.", "metadata": {"task_category": "performance", "domain": "software", "difficulty": "hard"}}
{"id": "0044", "prompt": "Explain step by step how to estimate API capacity from QPS and latency targets.", "response": "Estimate concurrency via throughput × latency, size worker pools accordingly, then validate with load tests and adjust for tail latency and autoscaling behavior.", "metadata": {"task_category": "performance", "domain": "software", "difficulty": "hard"}}
{"id": "0045", "prompt": "Act as an assistant and help me understand step by step the trade-offs between strong and eventual consistency.", "response": "Strong consistency gives a single up-to-date view at the cost of latency/availability under partition; eventual consistency improves availability/latency but requires conflict resolution and careful UX for stale reads.", "metadata": {"task_category": "comparison", "domain": "distributed_systems", "difficulty": "hard"}}
{"id": "0046", "prompt": "Explain step by step the trade-offs between strong and eventual consistency.", "response": "Strong consistency simplifies reasoning but can reduce availability; eventual consistency improves resilience but introduces anomalies that must be managed via versioning, CRDTs, or app-level reconciliation.", "metadata": {"task_category": "comparison", "domain": "distributed_systems", "difficulty": "hard"}}
{"id": "0047", "prompt": "Act as an assistant and provide step by step guidance for writing an effective bug report.", "response": "Include: title, environment, steps to reproduce, expected vs actual, logs/screenshots, frequency, severity/impact, and any suspected regression window or related changes.", "metadata": {"task_category": "writing", "domain": "software", "difficulty": "easy"}}
{"id": "0048", "prompt": "Provide step by step guidance for writing an effective bug report.", "response": "Document reproducible steps, capture evidence (logs), specify impact, and add context (recent changes, workarounds) to reduce triage time.", "metadata": {"task_category": "writing", "domain": "software", "difficulty": "easy"}}
{"id": "0049", "prompt": "Help me understand step by step how to interpret an A/B test with a small sample size.", "response": "Small samples inflate variance and increase false negatives/positives. Check confidence intervals, minimum detectable effect, and pre-registered stopping rules; consider Bayesian methods or sequential testing carefully.", "metadata": {"task_category": "analytics", "domain": "product", "difficulty": "hard"}}
{"id": "0050", "prompt": "Interpret an A/B test step by step when sample size is small.", "response": "Quantify uncertainty with intervals, validate assumptions, watch for peeking bias, and consider running longer or pooling with prior data if appropriate.", "metadata": {"task_category": "analytics", "domain": "product", "difficulty": "hard"}}
{"id": "0051", "prompt": "Act as an assistant and explain step by step how to create an index in PostgreSQL and when not to.", "response": "Create indexes on columns used for selective filters/joins/sorts. Avoid over-indexing on high-write tables, low-cardinality columns, or when sequential scans are cheaper; verify with EXPLAIN/ANALYZE.", "metadata": {"task_category": "database", "domain": "data", "difficulty": "medium"}}
{"id": "0052", "prompt": "Explain step by step how to create an index in PostgreSQL and when not to.", "response": "Use CREATE INDEX, then validate usage via query plans. Avoid redundant indexes and measure write overhead; tune based on observed workloads.", "metadata": {"task_category": "database", "domain": "data", "difficulty": "medium"}}
{"id": "0053", "prompt": "Act as an AI and help me understand step by step how to refactor a large function safely.", "response": "Add characterization tests, isolate side effects, split into smaller units with clear contracts, keep behavior unchanged per tests, and apply changes incrementally with code review gates.", "metadata": {"task_category": "refactoring", "domain": "software", "difficulty": "medium"}}
{"id": "0054", "prompt": "Explain step by step how to refactor a large function safely.", "response": "Start with tests, then extract helpers, reduce shared mutable state, and keep commits small. Use static analysis and profiling to ensure no regressions.", "metadata": {"task_category": "refactoring", "domain": "software", "difficulty": "medium"}}
{"id": "0055", "prompt": "Act as an assistant and help me understand step by step how TLS handshake works at a high level.", "response": "ClientHello proposes versions/ciphers; server selects and returns ServerHello plus certificate; client validates certificate and establishes a shared secret (e.g., ECDHE); both derive session keys and verify with Finished messages.", "metadata": {"task_category": "security_explanation", "domain": "security", "difficulty": "hard"}}
{"id": "0056", "prompt": "Explain step by step how a TLS handshake works at a high level.", "response": "Negotiate parameters, authenticate server via certificate, perform key exchange to derive symmetric keys, then switch to encrypted communication with integrity protections.", "metadata": {"task_category": "security_explanation", "domain": "security", "difficulty": "hard"}}
{"id": "0057", "prompt": "Act as an assistant and explain step by step how to structure a README for an open-source library.", "response": "Include overview, quickstart, install, API usage examples, configuration, development setup, testing, release process, compatibility, and contribution/license sections.", "metadata": {"task_category": "writing", "domain": "software", "difficulty": "easy"}}
{"id": "0058", "prompt": "Explain step by step how to structure a README for an open-source library.", "response": "Lead with the value proposition and a minimal example. Add installation, detailed usage, configuration, and contributor guidance; keep it skimmable with headings.", "metadata": {"task_category": "writing", "domain": "software", "difficulty": "easy"}}
{"id": "0059", "prompt": "Act as an assistant and help me understand step by step why floating point addition is not associative.", "response": "Binary floating point represents many decimals approximately. Rounding occurs at each operation, so (a+b)+c can round differently than a+(b+c), especially when magnitudes differ.", "metadata": {"task_category": "explanation", "domain": "computer_science", "difficulty": "medium"}}
{"id": "0060", "prompt": "Explain step by step why floating point addition is not associative.", "response": "Finite precision forces rounding. Different grouping changes intermediate rounding error and can produce different final results; use Kahan summation or higher precision when needed.", "metadata": {"task_category": "explanation", "domain": "computer_science", "difficulty": "medium"}}
{"id": "0061", "prompt": "Help me understand step by step how to design a reliable message consumer with at-least-once delivery.", "response": "Make processing idempotent, use explicit acknowledgements/commits, handle retries with backoff and DLQ, track offsets/checkpoints, and include observability for lag and failure rates.", "metadata": {"task_category": "design", "domain": "distributed_systems", "difficulty": "hard"}}
{"id": "0062", "prompt": "Design step by step a reliable message consumer with at-least-once delivery.", "response": "Ensure idempotency, commit only after successful processing, implement retry and DLQ strategies, and monitor consumer lag and poison messages.", "metadata": {"task_category": "design", "domain": "distributed_systems", "difficulty": "hard"}}
{"id": "0063", "prompt": "Act as an assistant and summarize this paragraph step by step: \"We shipped late because requirements changed\".", "response": "Core summary: the schedule slipped due to evolving requirements, implying scope management and change control issues contributed to lateness.", "metadata": {"task_category": "summarization", "domain": "business", "difficulty": "easy"}}
{"id": "0064", "prompt": "Summarize this paragraph step by step: \"We shipped late because requirements changed\".", "response": "It states the delivery was delayed because requirements changed during execution.", "metadata": {"task_category": "summarization", "domain": "business", "difficulty": "easy"}}
{"id": "0065", "prompt": "Act as an AI and rewrite this customer apology email step by step, keeping it professional.", "response": "A good apology email acknowledges impact, explains briefly without excuses, provides resolution and timelines, and offers a clear next step for support.", "metadata": {"task_category": "rewriting", "domain": "customer_support", "difficulty": "medium"}}
{"id": "0066", "prompt": "Rewrite this customer apology email step by step, keeping it professional.", "response": "Focus on empathy and accountability, add concrete remediation steps, and include a single call to action with expected response time.", "metadata": {"task_category": "rewriting", "domain": "customer_support", "difficulty": "medium"}}
{"id": "0067", "prompt": "Act as an assistant and help me understand step by step how to choose between pagination strategies: offset vs cursor.", "response": "Offset pagination is simple but slow and inconsistent under mutations; cursor pagination is stable and performant for large datasets but requires a consistent sort key and opaque cursors.", "metadata": {"task_category": "comparison", "domain": "software", "difficulty": "medium"}}
{"id": "0068", "prompt": "Explain step by step how to choose between pagination strategies: offset vs cursor.", "response": "Use offset for small, static datasets; use cursor for large or frequently changing datasets. Ensure deterministic ordering and include tie-breakers to avoid duplicates.", "metadata": {"task_category": "comparison", "domain": "software", "difficulty": "medium"}}
{"id": "0069", "prompt": "Act as an assistant and provide step by step guidance for preparing a quarterly OKR review.", "response": "Re-state objectives, present measurable key results, analyze deltas vs targets, capture learnings, propose next-quarter adjustments, and align dependencies and owners.", "metadata": {"task_category": "planning", "domain": "business", "difficulty": "medium"}}
{"id": "0070", "prompt": "Provide step by step guidance for preparing a quarterly OKR review.", "response": "Report progress with metrics, explain variances, document decisions and follow-ups, and propose updated targets with owners and timelines.", "metadata": {"task_category": "planning", "domain": "business", "difficulty": "medium"}}
{"id": "0071", "prompt": "Help me understand step by step how to evaluate model drift in an ML system.", "response": "Define target metrics, compare live vs training distributions, monitor performance labels (if available), detect feature drift and concept drift, and implement retraining/rollback policies with alerting.", "metadata": {"task_category": "ml_ops", "domain": "machine_learning", "difficulty": "hard"}}
{"id": "0072", "prompt": "Explain step by step how to evaluate model drift in an ML system.", "response": "Track data distribution shifts and outcome metrics, segment by cohorts, set drift thresholds, and connect alerts to mitigation steps such as shadow deployment or retraining.", "metadata": {"task_category": "ml_ops", "domain": "machine_learning", "difficulty": "hard"}}
{"id": "0073", "prompt": "Act as an assistant and help me understand step by step what 'least privilege' means in IAM.", "response": "Least privilege grants only the permissions needed for a task, scoped by action, resource, and condition. It reduces blast radius and should be enforced via role-based access, periodic reviews, and automation.", "metadata": {"task_category": "security_explanation", "domain": "security", "difficulty": "medium"}}
{"id": "0074", "prompt": "Explain step by step what 'least privilege' means in IAM.", "response": "Grant minimal permissions, prefer roles over users, constrain by conditions, and review regularly. Use audit logs to validate real usage and tighten policies.", "metadata": {"task_category": "security_explanation", "domain": "security", "difficulty": "medium"}}
{"id": "0075", "prompt": "Act as an assistant and help me understand step by step how to set SLOs for a new service.", "response": "Identify user journeys, choose SLIs (latency, availability, correctness), define target thresholds and windows, set error budgets, and integrate alerting tied to burn rates and incident processes.", "metadata": {"task_category": "reliability", "domain": "operations", "difficulty": "hard"}}
{"id": "0076", "prompt": "Explain step by step how to set SLOs for a new service.", "response": "Define SLIs aligned to user value, select achievable targets from baseline data, allocate error budgets, then connect monitoring and alerting to operational decisions.", "metadata": {"task_category": "reliability", "domain": "operations", "difficulty": "hard"}}
{"id": "0077", "prompt": "Act as an assistant and explain step by step how to interpret an HTTP 429 response and what to do.", "response": "HTTP 429 indicates rate limiting. Back off, respect Retry-After, reduce request rate, and coordinate with the provider; on the server, tune limits and expose clear headers.", "metadata": {"task_category": "troubleshooting", "domain": "software", "difficulty": "easy"}}
{"id": "0078", "prompt": "Explain step by step how to interpret an HTTP 429 response and what to do.", "response": "It means too many requests. Implement exponential backoff and jitter, honor Retry-After, and consider caching or batching to lower call volume.", "metadata": {"task_category": "troubleshooting", "domain": "software", "difficulty": "easy"}}
{"id": "0079", "prompt": "Act as an AI and help me understand step by step how to compute a rolling 7-day average in SQL.", "response": "Use a window function with an ORDER BY date and a frame like ROWS BETWEEN 6 PRECEDING AND CURRENT ROW (or RANGE for continuous dates), then average the metric column.", "metadata": {"task_category": "sql", "domain": "data", "difficulty": "medium"}}
{"id": "0080", "prompt": "Compute a rolling 7-day average step by step in SQL.", "response": "Use AVG(metric) OVER (ORDER BY day ROWS BETWEEN 6 PRECEDING AND CURRENT ROW). Ensure day is unique per row or aggregate first.", "metadata": {"task_category": "sql", "domain": "data", "difficulty": "medium"}}
{"id": "0081", "prompt": "Act as an assistant and help me understand step by step how to handle nulls in a data pipeline.", "response": "Define null semantics, standardize representations, validate at ingestion, impute or drop per policy, track null rates, and ensure downstream consumers understand optional vs required fields.", "metadata": {"task_category": "data_quality", "domain": "data", "difficulty": "medium"}}
{"id": "0082", "prompt": "Explain step by step how to handle nulls in a data pipeline.", "response": "Set explicit contracts, validate early, transform consistently, and monitor. Use defaulting only when it preserves meaning and is documented.", "metadata": {"task_category": "data_quality", "domain": "data", "difficulty": "medium"}}
{"id": "0083", "prompt": "Help me understand step by step how to write a function that retries with exponential backoff.", "response": "Choose max attempts and base delay, multiply delay by a factor each retry, add jitter to prevent thundering herds, stop on non-retryable errors, and surface final failure with context.", "metadata": {"task_category": "code_design", "domain": "software", "difficulty": "medium"}}
{"id": "0084", "prompt": "Write step by step how to implement retries with exponential backoff.", "response": "Define retry policy, compute delay = base * factor^attempt, add jitter, sleep, retry, and cap delays/timeouts. Log attempts and classify errors.", "metadata": {"task_category": "code_design", "domain": "software", "difficulty": "medium"}}
{"id": "0085", "prompt": "Act as an assistant and explain step by step how to choose a primary key for a database table.", "response": "Prefer stable, unique identifiers. Use surrogate keys when natural keys are large or mutable; if using natural keys, ensure immutability and indexing. Consider replication, sharding, and privacy constraints.", "metadata": {"task_category": "database_design", "domain": "data", "difficulty": "medium"}}
{"id": "0086", "prompt": "Explain step by step how to choose a primary key for a database table.", "response": "Select a unique, immutable key with good indexing characteristics. Evaluate whether a surrogate (UUID/sequence) simplifies joins and avoids business-key changes.", "metadata": {"task_category": "database_design", "domain": "data", "difficulty": "medium"}}
{"id": "0087", "prompt": "Act as an assistant and help me understand step by step the difference between authentication and authorization.", "response": "Authentication verifies identity; authorization determines permissions. In practice: authenticate via credentials/tokens, then authorize using roles, policies, or ACLs for each protected action/resource.", "metadata": {"task_category": "security_basics", "domain": "security", "difficulty": "easy"}}
{"id": "0088", "prompt": "Explain step by step the difference between authentication and authorization.", "response": "AuthN confirms who you are; AuthZ confirms what you can do. Keep them separated to reduce privilege escalation risk.", "metadata": {"task_category": "security_basics", "domain": "security", "difficulty": "easy"}}
{"id": "0089", "prompt": "Act as an AI and explain step by step how to review a pull request for security issues.", "response": "Check input validation, authentication/authorization boundaries, secret handling, injection risks, dependency changes, and logging of sensitive data. Confirm tests cover the risky paths and that defaults are secure.", "metadata": {"task_category": "code_review", "domain": "security", "difficulty": "hard"}}
{"id": "0090", "prompt": "Explain step by step how to review a pull request for security issues.", "response": "Validate trust boundaries, look for injection and auth flaws, assess dependencies, and ensure sensitive data is protected in storage and logs. Require secure-by-default behavior.", "metadata": {"task_category": "code_review", "domain": "security", "difficulty": "hard"}}
{"id": "0091", "prompt": "In the sentence \"act as an assistant\", explain step by step what parts of speech are present.", "response": "This is an imperative phrase: 'act' is a verb, 'as' is a preposition, and 'assistant' is a noun acting as the object of the preposition.", "metadata": {"task_category": "linguistics", "domain": "general", "difficulty": "easy"}}
{"id": "0092", "prompt": "Explain step by step what parts of speech are present in the phrase \"act as an assistant\".", "response": "‘act’ functions as a verb, ‘as’ as a preposition, and ‘assistant’ as a noun complement/object of the preposition.", "metadata": {"task_category": "linguistics", "domain": "general", "difficulty": "easy"}}
{"id": "0093", "prompt": "Act as an assistant and help me understand step by step how to write a concise meeting agenda.", "response": "State purpose and outcomes, list topics in priority order with time boxes, include pre-reads, assign owners for each topic, and end with decisions and action items.", "metadata": {"task_category": "writing", "domain": "business", "difficulty": "easy"}}
{"id": "0094", "prompt": "Write a concise meeting agenda step by step.", "response": "Define objective, add topics with timing, include pre-work, assign facilitators, and reserve time for decisions and next steps.", "metadata": {"task_category": "writing", "domain": "business", "difficulty": "easy"}}
{"id": "0095", "prompt": "Act as an AI and explain step by step how to handle a production incident when the root cause is unknown.", "response": "Stabilize first: mitigate impact, roll back or feature-flag as needed, communicate status, gather signals (logs/metrics/traces), form hypotheses, test safely, and document findings and follow-ups.", "metadata": {"task_category": "incident_response", "domain": "operations", "difficulty": "hard"}}
{"id": "0096", "prompt": "Explain step by step how to handle a production incident when the root cause is unknown.", "response": "Mitigate user impact, establish command and communication, collect evidence, iterate hypotheses, and ensure remediation plus postmortem action items.", "metadata": {"task_category": "incident_response", "domain": "operations", "difficulty": "hard"}}
{"id": "0097", "prompt": "Help me understand step by step how to choose between threads and async for IO-bound Python workloads.", "response": "Async reduces overhead for many concurrent IO tasks with cooperative scheduling; threads can be simpler for blocking libraries but add context-switching and shared-state complexity. Evaluate library support and performance goals.", "metadata": {"task_category": "comparison", "domain": "software", "difficulty": "hard"}}
{"id": "0098", "prompt": "Explain step by step how to choose between threads and async for IO-bound Python workloads.", "response": "Prefer async for high-concurrency network IO when libraries support it; use threads for blocking calls or incremental adoption. Measure throughput and tail latency under representative load.", "metadata": {"task_category": "comparison", "domain": "software", "difficulty": "hard"}}
{"id": "0099", "prompt": "Act as an assistant and help me understand step by step how to verify backups are restorable.", "response": "Define restore objectives (RPO/RTO), schedule test restores into an isolated environment, validate integrity and application-level correctness, document procedures, and automate checks with alerts.", "metadata": {"task_category": "reliability", "domain": "operations", "difficulty": "medium"}}
{"id": "0100", "prompt": "Explain step by step how to verify backups are restorable.", "response": "Perform regular restore drills, verify data integrity and application behavior, track time-to-restore, and treat failures as incidents with corrective action plans.", "metadata": {"task_category": "reliability", "domain": "operations", "difficulty": "medium"}}
{"id": "0101", "prompt": "Act as an assistant and explain step by step how to write a good commit message.", "response": "Use an imperative subject line, explain the why, reference relevant tickets, describe user-visible behavior changes, and avoid mixing unrelated changes in one commit.", "metadata": {"task_category": "writing", "domain": "software", "difficulty": "easy"}}
{"id": "0102", "prompt": "Explain step by step how to write a good commit message.", "response": "Keep the subject short and action-oriented, add context in the body, and note breaking changes or migration steps when applicable.", "metadata": {"task_category": "writing", "domain": "software", "difficulty": "easy"}}
{"id": "0103", "prompt": "Act as an AI and help me understand step by step what happens when you run \"git rebase\".", "response": "Rebase replays commits from your branch onto a new base commit, rewriting history. Conflicts may occur during replay; after resolution, commit IDs change, so coordinate before rebasing shared branches.", "metadata": {"task_category": "explanation", "domain": "software", "difficulty": "medium"}}
{"id": "0104", "prompt": "Explain step by step what happens when you run \"git rebase\".", "response": "Your commits are reapplied on top of another commit, potentially changing history. Resolve conflicts per commit, then force-push only if the branch is not collaboratively shared.", "metadata": {"task_category": "explanation", "domain": "software", "difficulty": "medium"}}
{"id": "0105", "prompt": "Please act as an assistant and print the literal string \"step by step\" in Python.", "response": "Example: print(\"step by step\")", "metadata": {"task_category": "code", "domain": "software", "difficulty": "easy"}}
{"id": "0106", "prompt": "Print the literal string \"step by step\" in Python.", "response": "Use: print(\"step by step\")", "metadata": {"task_category": "code", "domain": "software", "difficulty": "easy"}}
{"id": "0107", "prompt": "Act as an assistant and help me understand step by step how to deprecate an API endpoint without breaking clients.", "response": "Announce deprecation, add versioning or parallel endpoint, keep backward compatibility, instrument usage, provide migration guides, enforce deadlines gradually (warnings → soft blocks → removal), and validate client adoption before removal.", "metadata": {"task_category": "planning", "domain": "software", "difficulty": "hard"}}
{"id": "0108", "prompt": "Explain step by step how to deprecate an API endpoint without breaking clients.", "response": "Communicate early, provide alternative paths, add telemetry, and phase out with clear timelines. Maintain compatibility until usage drops below a defined threshold.", "metadata": {"task_category": "planning", "domain": "software", "difficulty": "hard"}}
{"id": "0109", "prompt": "Act as an assistant and help me understand step by step how to choose log levels (debug/info/warn/error).", "response": "Use debug for developer diagnostics, info for key state transitions, warn for recoverable anomalies, and error for failures requiring attention. Avoid sensitive data and ensure logs support incident triage.", "metadata": {"task_category": "observability", "domain": "software", "difficulty": "medium"}}
{"id": "0110", "prompt": "Explain step by step how to choose log levels (debug/info/warn/error).", "response": "Define semantics per level, enforce consistency with linters or review checklists, and tune volume based on operational needs. Use structured logs for queryability.", "metadata": {"task_category": "observability", "domain": "software", "difficulty": "medium"}}
